<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
</head>

<body>
</body>

<script>
class RequestQueue {
  limit = 0;
  count = 0;
  queue = [];
    constructor(maxLength) {
      this.limit = maxLength;
    };
    run() {
      if (this.count === this.limit) {
        return;
      }
      const func = this.queue.shift();
      count++;
      return new Promise((resolve, reject) => {


        
        func().then((val) => {
          resolve(val);
          this.run();
          count--;
        })
      })
    }
    request(func) {
      this.queue.push(func);
      return this.run();
    }
}

const instance = new RequestQueue(3)

const promise1 = instance.request(async () => {
    await delay(100)
    return 1
})
const promise2 = instance.request(async () => {
    await delay(1000)
    return 2
})
const promise3 = instance.request(async () => {
    await delay(700)
    return 3
})
const promise4 = instance.request(async () => {
    // 等待100ms后执行
    await delay(900)
    return 4
})

await promise1 // 1
await promise4 // 4


// 场景1
span.addEventListener('click', () => {
    setTimeout(() => {
        while(true){
            console.log(1)
        }
    });
    this.style.color="red"
})
// 场景2
span.addEventListener('click', () => {
    Promise.resolve(2).then(res => {
        while(true){
            console.log(res)
        }
    })
    this.style.color="red"
 })


//  以k个为一组翻转链表
// 输入一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
// k 是一个正整数，它的值小于或等于链表的长度。
// 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
// 输入描述
// 1. head = [1,2,3,4,5], k = 2
// 2. head = [1,2,3,4,5], k = 3
// 3. head = [1,2,3,4,5], k = 1
// 4. head = [1], k = 1
// 输出描述
// 1. [2,1,4,3,5]
// 2. [3,2,1,4,5]
// 3. [1,2,3,4,5]
// 4. [1]
// 注：这里的 [1,2,3,4,5] 并不是数组，而是链表结构，只是为了方便表达才如此描述。

class Node {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

const reverse = (root, end) => {
  const pre = new Node(), node = root;
  while (node && node.next && node !== end) {
    const next = node.next;
    const nextnext = node.next.next
    pre.next = node.next;
    node.next = nextnext;
    next.next = node;
    node = node.next;
  }
}

const reverseKNode = (root, k) => {

  const dummy = new Node();
  dummy.next = root;
  let slow = dummy, fast = dummy, i = 0;
  while (true) {
    while (i <= k && fast.next) {
      fast = fast.next;
      i++;
    }
    if (i < k) break;
    reverse(slow, fast);
    slow = fast;
    i = 0;
  }

  return dummy.next;
}

function create(func) {
  var obj = Object.create(func.prototype);
  const ret = func.call(obj);
  return typeof ret === 'object' ? ret : obj;
}
</script>

<style>
</style>
</html>